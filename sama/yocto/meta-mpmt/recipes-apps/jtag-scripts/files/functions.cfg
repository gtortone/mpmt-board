# FUNCTIONS

proc set_jtag_speed_low {} {
   adapter speed 2000
}

proc set_jtag_speed_medium {} {
   adapter speed 15000
}

proc set_jtag_speed_hi {} {
   adapter speed 30000
}

proc zynqpl_program {tap} {
   set XC7_JSHUTDOWN 0x0d
   set XC7_JPROGRAM 0x0b
   set XC7_JSTART 0x0c
   set XC7_BYPASS 0x3f
	irscan $tap $XC7_JSHUTDOWN
	irscan $tap $XC7_JPROGRAM
	runtest 60000
	#JSTART prevents this from working...
	#irscan $tap $XC7_JSTART
	runtest 2000
	irscan $tap $XC7_BYPASS
	runtest 2000
}

proc zynqpl_reset_release {target} {
   # Unlock SLCR
    $target mww 0xf8000008 0xdf0d
    # Enable level shifters, both PL-PS and PS-PL
    $target mww 0xf8000900 0xF
    # Release FPGA reset
    $target mww 0xf8000240 0x0
    # Lock SLCR
    $target mww 0xf8000004 0x767b
}

#
# Hack to get the registers into a stable state when first booting a zynq in
# JTAG mode. If r11 is pointing to an invalid address and you use gdb to set a
# register the write will fail because gdb attempts to scan or unwind the
# current frame and the bad address seems to lock the bus up. This code puts
# the registers into the OCM and hopefull safe.
#
proc zynq_clear_registers { target } {
    echo "Zynq-7000 Series setup: $target"
    set _OCM_END 0x0003FFF0
    mww phys 0xF8007000 0x4E00E07F
    reg r0 0
    reg r1 0
    reg r2 0
    reg r3 0
    reg r4 0
    reg r5 0
    reg r6 0
    reg r7 0
    reg r8 0
    reg r9 0
    reg r10 0
    reg r11 $_OCM_END
    reg sp_svc $_OCM_END
    reg lr_svc $_OCM_END
    reg sp_abt $_OCM_END
    reg lr_abt $_OCM_END
    reg sp_und $_OCM_END
    reg lr_und $_OCM_END
}

proc zynq_disable_mmu_and_caches { target } {
    # arm mcr pX op1 CRn CRm op2 value
    echo "Disable MMU and caches"
    # Invalidate caches
    catch {
        $target arm mcr 15 0 7 5 0 0
        $target arm mcr 15 0 7 7 0 0
        # Invalidate all TLBs
        $target arm mcr 15 0 8 5 0 0
        $target arm mcr 15 0 8 6 0 0
        $target arm mcr 15 0 8 7 0 0
        $target arm mcr 15 4 8 3 0 0
        $target arm mcr 15 4 8 7 0 0
        set cp [$target arm mrc 15 0 1 0 0]
        echo "SCTRL => [format 0x%x $cp]"
        set mask [expr 1 << 29 | 1 << 12 | 1 << 11 | 1 << 2 | 1 << 1 | 1 << 0]
        set cp [expr ($cp & ~$mask)]
        $target arm mcr 15 0 1 0 0 $cp
        echo "SCTRL <= [format 0x%x $cp]"
    }
}

proc zynq_boot_ocm_setup { } {
    #
    # Enable the OCM
    #
    echo "Zynq Boot OCM setup"
    catch {
      mww phys 0xF8000008 0xDF0D
      mww phys 0xF8000238 0
      mww phys 0xF8000910 0xC
    }
}

proc zynq_rtems_setup { } {
    cache_config l2x 0xF8F02000 8
    cortex_a maskisr on
}

proc zynq_restart { wait } {
    echo "Zynq reset, resetting the board ... "
    poll off
    #
    # Issue the reset via the SLCR
    #
    catch {
        mww phys 0xF8000008 0xDF0D
        mww phys 0xF8000200 1
    }
    echo "Zynq reset waiting for $wait msecs ... "
    sleep $wait
    #
    # Reconnect the DAP etc due to the reset.
    #
    zynq.cpu0 cortex_a dbginit
    zynq.cpu0 arm core_state arm

    poll on
    #
    # We can now halt the core.
    #

    targets zynq.cpu0
    halt
    zynq_rtems_setup
}

proc zynq_gdb_attach { target } {
    catch {
      halt
    }
}


